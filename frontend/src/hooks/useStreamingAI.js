/**
 * Streaming AI Hook
 *
 * Consumes Server-Sent Events (SSE) from AI streaming endpoints.
 * Provides real-time content as it's generated by Claude.
 *
 * Features:
 * - Real-time streaming content
 * - Progress tracking
 * - Error handling with retry
 * - Abort/cancel support
 *
 * Usage:
 * const { content, isStreaming, error, generate, abort } = useStreamingAI();
 *
 * // Start generation
 * await generate('/api/ai/stream/devotional', { topic: 'Grace' });
 */

import { useState, useCallback, useRef } from 'react';
import { useAuth } from '../context/AuthContext';

const API_BASE = import.meta.env.VITE_API_URL || '';

/**
 * @typedef {Object} StreamingState
 * @property {string} content - Generated content so far
 * @property {boolean} isStreaming - Whether currently streaming
 * @property {boolean} isComplete - Whether generation completed
 * @property {Error|null} error - Any error that occurred
 * @property {number} chunkCount - Number of chunks received
 */

/**
 * Hook for consuming streaming AI responses
 */
export function useStreamingAI() {
  const { token } = useAuth();
  const [content, setContent] = useState('');
  const [isStreaming, setIsStreaming] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const [error, setError] = useState(null);
  const [chunkCount, setChunkCount] = useState(0);

  const abortControllerRef = useRef(null);

  /**
   * Start streaming content generation
   * @param {string} endpoint - API endpoint (e.g., '/api/ai/stream/devotional')
   * @param {object} params - Request parameters
   */
  const generate = useCallback(async (endpoint, params) => {
    // Reset state
    setContent('');
    setIsStreaming(true);
    setIsComplete(false);
    setError(null);
    setChunkCount(0);

    // Create abort controller
    abortControllerRef.current = new AbortController();

    try {
      const response = await fetch(`${API_BASE}${endpoint}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(params),
        signal: abortControllerRef.current.signal,
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      while (true) {
        const { done, value } = await reader.read();

        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        // Parse SSE events from buffer
        const lines = buffer.split('\n');
        buffer = lines.pop() || ''; // Keep incomplete line in buffer

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();

          if (line.startsWith('event:')) {
            const eventType = line.slice(6).trim();

            // Get the next line which should be data
            if (i + 1 < lines.length && lines[i + 1].startsWith('data:')) {
              const dataLine = lines[i + 1];
              const jsonStr = dataLine.slice(5).trim();

              try {
                const data = JSON.parse(jsonStr);

                if (eventType === 'message' && data.content) {
                  setContent((prev) => prev + data.content);
                  setChunkCount((prev) => prev + 1);
                } else if (eventType === 'done') {
                  setIsComplete(true);
                } else if (eventType === 'error') {
                  throw new Error(data.error || 'Generation failed');
                }
              } catch (parseError) {
                // Ignore parse errors for malformed chunks
              }

              i++; // Skip the data line
            }
          } else if (line.startsWith('data:')) {
            // Handle data without event type
            const jsonStr = line.slice(5).trim();
            try {
              const data = JSON.parse(jsonStr);
              if (data.content) {
                setContent((prev) => prev + data.content);
                setChunkCount((prev) => prev + 1);
              }
              if (data.done) {
                setIsComplete(true);
              }
            } catch {
              // Ignore parse errors
            }
          }
        }
      }

      setIsComplete(true);
    } catch (err) {
      if (err.name === 'AbortError') {
        // User cancelled, not an error
        return;
      }
      setError(err);
    } finally {
      setIsStreaming(false);
      abortControllerRef.current = null;
    }
  }, [token]);

  /**
   * Abort current generation
   */
  const abort = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      setIsStreaming(false);
    }
  }, []);

  /**
   * Reset state
   */
  const reset = useCallback(() => {
    setContent('');
    setIsStreaming(false);
    setIsComplete(false);
    setError(null);
    setChunkCount(0);
  }, []);

  return {
    content,
    isStreaming,
    isComplete,
    error,
    chunkCount,
    generate,
    abort,
    reset,
  };
}

/**
 * Hook for streaming devotional generation
 */
export function useStreamingDevotional() {
  const streaming = useStreamingAI();

  const generateDevotional = useCallback(
    (options = {}) => {
      return streaming.generate('/api/ai/stream/devotional', {
        topic: options.topic,
        scripture_reference: options.scriptureReference,
        length: options.length || 'medium',
        language: options.language || 'en',
      });
    },
    [streaming]
  );

  return {
    ...streaming,
    generateDevotional,
  };
}

/**
 * Hook for streaming sermon notes generation
 */
export function useStreamingSermonNotes() {
  const streaming = useStreamingAI();

  const generateSermonNotes = useCallback(
    (options) => {
      return streaming.generate('/api/ai/stream/sermon-notes', {
        title: options.title,
        scripture_references: options.scriptureReferences,
        key_points: options.keyPoints,
        style: options.style || 'expository',
        language: options.language || 'en',
      });
    },
    [streaming]
  );

  return {
    ...streaming,
    generateSermonNotes,
  };
}

export default useStreamingAI;
